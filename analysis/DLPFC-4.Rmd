---
title: "DLPFC"
output:
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: console
---

# Introduction
Here, we apply KODAMA to analyze the human dorsolateral prefrontal cortex (DLPFC) data by 10x Visium from [Maynard et al., 2021](https://www.nature.com/articles/s41593-020-00787-0). The links to download the raw data and H&E full resolution images can be found in the [LieberInstitute/spatialLIBD](https://github.com/LieberInstitute/spatialLIBD) github page.

# Loading the required libraries
```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
library("nnSVG")
library("scater")
library("scran")
library("scry")
library("SPARK")
library("harmony")
library("Seurat")
library("spatialLIBD")
library("KODAMA")
library("KODAMAextra")
library("mclust")
```

# Download the dataset
```{r, eval=FALSE}
spe <- fetch_data(type = 'spe')
```

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE, echo=FALSE}
load("../DLFPC.RData")
```

## Extract the metadata information
```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
sample_names=c("151507",
               "151508",
               "151509",
               "151510",
               "151669",
               "151670",
               "151671",
               "151672",
               "151673",
               "151674",
               "151675",
               "151676")
subject_names= c("Br5292","Br5595", "Br8100")
metaData = SingleCellExperiment::colData(spe)
expr = SingleCellExperiment::counts(spe)
sample_names <- paste0("sample_", unique(colData(spe)$sample_id))
sample_names <-  unique(colData(spe)$sample_id)
dim(spe)
```

# Preprocessing
## Quality control
We identified mitochondrial genes, calculated per-spot QC metrix and select the QC threshoulds.
Low quality spots are discarded.

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)
table(is_mito)
spe <- addPerCellQC(spe, subsets = list(mito = is_mito))

# select QC thresholds
qc_lib_size <- colData(spe)$sum < 500
qc_detected <- colData(spe)$detected < 250
qc_mito <- colData(spe)$subsets_mito_percent > 30
qc_cell_count <- colData(spe)$cell_count > 12

discard <- qc_lib_size | qc_detected | qc_mito | qc_cell_count
table(discard)
colData(spe)$discard <- discard

spe <- spe[, !colData(spe)$discard]
dim(spe)

```

Spots that are not assigned to any tissue regions are removed from the analysis.

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
sel= !is.na(colData(spe)$layer_guess_reordered)
spe = spe[,sel]
dim(spe)
```

## Horizontalization
The position of spots is corrected to allow to set the slides in the same XY plane.

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
xy=spatialCoords(spe)
samples=unique(colData(spe)$sample_id)
for(j in 1:length(samples)){
  sel=samples[j]==colData(spe)$sample_id
  xy[sel,1]=spatialCoords(spe)[sel,1]+12000*(j-1)
}
spatialCoords(spe)=xy
```


## Gene filtering
```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}

spe <- filter_genes(
  spe,
  filter_genes_ncounts = 2,   #ncounts
  filter_genes_pcspots = 0.5,
  filter_mito = TRUE
)

dim(spe)
```


## Normalization
```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}
spe <- computeLibraryFactors(spe)
spe <- logNormCounts(spe)
```

## Gene selection
The identification of genes that display spatial expression patterns is performed using the SPARKX method ([Zhu et al. (2021)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-021-02404-0)). The genes are ranked based on the median value of the logarithm value of the p-value obtained in each slide individually.


```{r, fig.width=10, fig.height=4,results = "hide"}
gene_i=NULL
pvalue_i=NULL
pvalue_mat=matrix(nrow=nrow(spe),ncol=length(sample_names))
for(i in 1:length(sample_names)){
  sel=colData(spe)$sample_id==sample_names[i]
  spe_sub= spe[,sel]

  sparkX <- sparkx(logcounts(spe_sub),spatialCoords(spe_sub),numCores=1,option="mixture")

  gene_i=c(gene_i,rowData(spe)$gene_id)
  pvalue_i=c(pvalue_i,sparkX$res_mtest$combinedPval)
  pvalue_mat[,i]=sparkX$res_mtest$combinedPval
  print(sample_names[i])
}
oo=order(pvalue_i)
top_genes=gene_i[oo]
n=ave(1:length(top_genes), top_genes, FUN = seq_along)
top_genes=top_genes[n==1]

oo=order(apply(pvalue_mat,1,function(x) median(-log(x))),decreasing = TRUE)
top=gene_i[oo]
```

# Patient Br5595

subject_names= c("Br5292","Br5595", "Br8100")
```{r, fig.width=10, fig.height=4}

subject_names="Br5595"

  spe_sub <- spe[, colData(spe)$subject ==  subject_names]
  subjects=colData(spe_sub)$subject
  dim(spe_sub)
  spe_sub <- runPCA(spe_sub, 50,subset_row = top[1:2000], scale=TRUE)

  pca=reducedDim(spe_sub,type = "PCA")[,1:50]
  labels=as.factor(colData(spe_sub)$layer_guess_reordered)
  xy=as.matrix(spatialCoords(spe_sub))
  samples=colData(spe_sub)$sample_id
  data=t(logcounts(spe_sub)[top[1:2000],])
  
  plot(pca, col=as.factor(colData(spe_sub)$sample_id))


```

## KODAMA analysis

```{r, fig.width=10, fig.height=4}
kk=KODAMA.matrix.parallel(pca,
                            spatial = xy,
                            FUN= "PLS" ,
                            landmarks = 100000,
                            splitting = 100,
                            f.par.pls = 50,
                            spatial.resolution = 0.4,
                            n.cores=4)

  print("KODAMA finished")
  
     config=umap.defaults
     config$n_threads = 4
     config$n_sgd_threads = "auto"
     kk_UMAP=KODAMA.visualization(kk,method="UMAP",config=config)

     plot(kk_UMAP,col=as.factor(labels))
```

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE, echo=FALSE}
save(kk_UMAP,file="output/DLFPC-Br5595.RData")
```

## Kmeans clustering

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}

 clu=kmeans(kk_UMAP,5,nstart = 100)$cluster
  plot(kk_UMAP,col=labels,pch=20)
  plot(kk_UMAP,col=clu,pch=20)

plot(xy,col=clu,pch=20)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],clu[sel]))
}

ref=refine_SVM(xy,clu,samples,cost=100)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],ref[sel]))
}
plot(xy,col=ref,pch=20)

#############################

  clu=kmeans(kk_UMAP,7,nstart = 100)$cluster
  plot(kk_UMAP,col=labels,pch=20)
  plot(kk_UMAP,col=clu,pch=20)

plot(xy,col=clu,pch=20)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],clu[sel]))
}

ref=refine_SVM(xy,clu,samples,cost=100)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],ref[sel]))
}
plot(xy,col=ref,pch=20)


###################

 clu=kmeans(kk_UMAP,8,nstart = 100)$cluster
  plot(kk_UMAP,col=labels,pch=20)
  plot(kk_UMAP,col=clu,pch=20)

plot(xy,col=clu,pch=20)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],clu[sel]))
}

ref=refine_SVM(xy,clu,samples,cost=100)

u=unique(samples)
for(i in 1:length(u)){
  sel=samples==u[i]
  print(adjustedRandIndex(labels[sel],ref[sel]))
}
plot(xy,col=ref,pch=20)

```



## Graph-based clustering

```{r, fig.width=10, fig.height=4, warning=FALSE, message=FALSE}

    # Graph-based clustering
    g <- bluster::makeSNNGraph(as.matrix(kk_UMAP), k = 20)
    g_walk <- igraph::cluster_walktrap(g)
    clu <- as.character(igraph::cut_at(g_walk, no = 2))
    plot(kk_UMAP,col=clu,pch=20)
    

    
    g <- bluster::makeSNNGraph(as.matrix(kk_UMAP), k = 20)
    g_walk <- igraph::cluster_walktrap(g)
    clu <- as.character(igraph::cut_at(g_walk, no = 5))
    plot(kk_UMAP,col=clu,pch=20)
    
    ref=refine_SVM(xy,clu,samples,cost=100)

    u=unique(samples)
    for(i in 1:length(u)){
      sel=samples==u[i]
      print(adjustedRandIndex(labels[sel],ref[sel]))
    }
    plot(xy,col=ref,pch=20)
``` 